name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version/Tag to deploy'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ vars.APP_URL }}

    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        run: |
          if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            echo "DEPLOY_ENV=staging" >> $GITHUB_ENV
            echo "DEPLOY_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.STAGING_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_KEY=${{ secrets.STAGING_SSH_KEY }}" >> $GITHUB_ENV
          else
            echo "DEPLOY_ENV=production" >> $GITHUB_ENV
            echo "DEPLOY_HOST=${{ secrets.PRODUCTION_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.PRODUCTION_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_KEY=${{ secrets.PRODUCTION_SSH_KEY }}" >> $GITHUB_ENV
          fi

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.DEPLOY_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment package
        run: |
          tar czf deployment.tar.gz \
            docker-compose.prod.yml \
            ops/docker/nginx/ \
            ops/monitoring/

      - name: Copy files to server
        run: |
          scp -i ~/.ssh/deploy_key deployment.tar.gz \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:/tmp/

      - name: Deploy via SSH
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'ENDSSH'
            set -e

            # Extract deployment package
            cd /opt/parkshare
            tar xzf /tmp/deployment.tar.gz

            # Set environment variables
            export VERSION=${{ github.event.inputs.version || github.ref_name }}
            export DOCKER_REGISTRY=${{ env.REGISTRY }}
            export DOCKER_IMAGE=${{ env.IMAGE_NAME }}

            # Pull latest images
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin
            docker compose -f docker-compose.prod.yml pull

            # Run database migrations
            docker compose -f docker-compose.prod.yml run --rm app npm run migration:run

            # Deploy with zero-downtime
            docker compose -f docker-compose.prod.yml up -d --no-deps --build app

            # Wait for health check
            sleep 10

            # Verify deployment
            curl -f http://localhost:3000/health || exit 1

            # Clean up old images
            docker image prune -af --filter "until=24h"

            echo "Deployment completed successfully!"
          ENDSSH

      - name: Run smoke tests
        run: |
          sleep 30
          curl -f ${{ vars.APP_URL }}/health
          curl -f ${{ vars.APP_URL }}/api

      - name: Notify deployment success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "✅ Deployment to ${{ env.DEPLOY_ENV }} successful!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Successful* ✅\n*Environment:* ${{ env.DEPLOY_ENV }}\n*Version:* ${{ github.event.inputs.version || github.ref_name }}\n*Deployed by:* ${{ github.actor }}"
                  }
                }
              ]
            }

      - name: Notify deployment failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "❌ Deployment to ${{ env.DEPLOY_ENV }} failed!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Failed* ❌\n*Environment:* ${{ env.DEPLOY_ENV }}\n*Version:* ${{ github.event.inputs.version || github.ref_name }}\n*Deployed by:* ${{ github.actor }}\n*Check:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        run: |
          ssh -i ~/.ssh/deploy_key ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            cd /opt/parkshare
            docker compose -f docker-compose.prod.yml down
            docker compose -f docker-compose.prod.yml up -d
          ENDSSH
